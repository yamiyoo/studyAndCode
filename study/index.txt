指针和存储区捆绑关系可随着程序执行改变
指针代表存储区的某种特征
如果指针和数组里第一个存储区捆绑则通过这个指针
    可找到数组里每一个存储区
在指针下面加下标找到对应存储区
地址数据只能参与有限的数据计算
   地址+-整数（增加整数个存储区大小）n*相差字节
   地址-地址（两个地址间包含的捆绑存储区个数）

*捆绑过得指针  可以赋值
不同类型指针适合不同类型存储区
一条语句可以声明多个同类型指针变量,每个变量前单独*
	int *p;
	int num = 0;
	*p = &num
没有捆绑过得指针分为
	空指针(NULL)记录空地址,地址数值就是0
	野指针
程序里禁止出现野指针,所有指针必须初始化*p = NULL,*没有参与赋值过程

可以采用如下写法表示数组下标为num的存储区
	*（p_num+num）
声明指针变量const关键字
可以在声明指针变量时把const关键字写在类型前
   const int *p_num=&num;
   p_num=NULL;//空地址
   *p_num=10(❌)
程序中不刻意通过这种指针对他捆绑存储区赋值
	可对指针本身赋值
可在声明指针变量时候把const关键字写在指针变量名称前
可通过这种指针对捆绑存储区赋值，不能对指针本身赋值
	int *const p_num1= &num
	*p_num1=10；
	p_num1=NULL（❌）
特殊指针（void作为类型名称）：无类型指针
这种指针可和任意类型存储区捆绑，无法通过指针知道
	捆绑存储区类型
不应该在无类型指针前加*也不应该对他加减整数计算
这种指针必须先强制转换成有类型指针再使用
	viod *p_v = &ch;
	*(char *)p_v
存储区可跨函数使用（通过指针实现）
数组形参
声明指针形参尽可能在类型名称前使用const关键字
无类型指针通常作为形式参数使用
使用地址作为返回值可以让调用函数使用被调用函数
	提供存储区，被调用函数提供指针类型存储区作为
	返回地址
	    int *read(void){
		int num；
	    return &num;}（❌）
	不可以把局部地址作为返回值使用，生命周期决定
	解决方法：1声明成静态变量 static int num；
		2整数类型指针形参得到调用函数整数类型存储区
不可把非静态局部变量 地址作为返回值使用
